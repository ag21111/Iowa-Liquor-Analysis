}
}
# Iterate through columns with odds (assuming they start from a certain column)
odds.columns <- 2:ncol(DT)  # Adjust this range based on your data
for (col in odds.columns) {
# Get column name for reference
col.name <- colnames(DT)[col]
# Calculate implied probabilities for each value in the column
implied.probabilities <- sapply(DT[[col]], calculate.implied.probability)
# Add new column with implied probabilities
new.col.name <- paste0(col.name, ".Implied Prob")  # New column name
DT[[new.col.name]] <- implied.probabilities
}
# Generate house edge
# Initialize a list to store results
results <- list()
# Loop over each column index (1 to 3 for three columns)
for (col.index in 5:7) {
# Select the current column index for each row
selected.column.index <- rep(col.index, n)
# Calculate the product of values for each row in the selected column
products <- apply(DT[, col.index], 1, prod)
# Store the results in a dataframe
result.df <- data.frame(
Selected.Column.Index = selected.column.index,
Product = products
)
# Append the result dataframe to the results list
results[[col.index]] <- result.df
}
# Combine all results into a single dataframe
final.results <- do.call(rbind, results)
View(final.results)
ll.combinations <- expand.grid(DT)
all.combinations <- expand.grid(DT)
View(all.combinations)
all.combinations <- expand.grid(Var1 = c("Favorite wins, Draw, Underdog wins"))
View(all.combinations)
all.combinations <- expand.grid(DT, Var1 = c("Favorite wins, Draw, Underdog wins"))
View(all.combinations)
all.combinations <- expand.grid(DT, Var1 = c("Favorite wins", "Draw", "Underdog wins"))
View(all.combinations)
View(all.combinations)
options <- list(
outcome = c("Favorite wins", "Draw", "Underdog wins")
)
View(options)
options[["outcome"]]
expand.grid
expand.grid(options)
outcomes <- expand.grid(options)
View(outcomes)
options <- list(
DT = DT
outcome = c("Favorite wins", "Draw", "Underdog wins")
View(DT)
options <- list(
DT = DT$Match,
outcome = c("Favorite wins", "Draw", "Underdog wins")
)
View(options)
options[["DT"]]
outcomes <- expand.grid(options)
View(outcomes)
library(combinat)
library(writexl)
library(readxl)
# Data and basic processing -----------------------------------------------
# Import odds ratios for each team
DT <- read_excel("C:/Users/azizg/Downloads/Betting.xlsx", sheet = "Odds")
# Generate implied probabilities
calculate.implied.probability <- function(odds) {
if (odds >= 0) {
return(100 / (odds + 100))
} else {
return(odds / (odds - 100))
}
}
# Iterate through columns with odds (assuming they start from a certain column)
odds.columns <- 2:ncol(DT)  # Adjust this range based on your data
for (col in odds.columns) {
# Get column name for reference
col.name <- colnames(DT)[col]
# Calculate implied probabilities for each value in the column
implied.probabilities <- sapply(DT[[col]], calculate.implied.probability)
# Add new column with implied probabilities
new.col.name <- paste0(col.name, ".Implied Prob")  # New column name
DT[[new.col.name]] <- implied.probabilities
}
# Generate house edge
# Generating different lines ----------------------------------------------
# Different outcomes that can happen
options <- list(
Match = DT$Match,
Outcome = c("Favorite wins", "Draw", "Underdog wins")
)
outcomes <- expand.grid(options)
# Merge outcomes onto the datatable
merged.df <- merge(outcomes, DT, by = "Match")
View(merged.df)
library(dplyr)
install.packages("dplyr")
library(dplyr)
library(combinat)
library(writexl)
library(readxl)
library(dplyr)
# Data and basic processing -----------------------------------------------
# Import odds ratios for each team
DT <- read_excel("C:/Users/azizg/Downloads/Betting.xlsx", sheet = "Odds")
# Generate implied probabilities
calculate.implied.probability <- function(odds) {
if (odds >= 0) {
return(100 / (odds + 100))
} else {
return(odds / (odds - 100))
}
}
# Iterate through columns with odds (assuming they start from a certain column)
odds.columns <- 2:ncol(DT)  # Adjust this range based on your data
for (col in odds.columns) {
# Get column name for reference
col.name <- colnames(DT)[col]
# Calculate implied probabilities for each value in the column
implied.probabilities <- sapply(DT[[col]], calculate.implied.probability)
# Add new column with implied probabilities
new.col.name <- paste0(col.name, ".Implied Prob")  # New column name
DT[[new.col.name]] <- implied.probabilities
}
# Generate house edge
# Generating different lines ----------------------------------------------
# Different outcomes that can happen
options <- list(
Match = DT$Match,
Outcome = c("Favorite wins", "Draw", "Underdog wins")
)
outcomes <- expand.grid(options)
# Merge outcomes onto the datatable
merged.df <- merge(outcomes, DT, by = "Match")
# Group by 'Group' and generate combinations of 'Values'
df.combinations <- merged.df %>%
group_by(Match) %>%
summarize(Combinations = list(combn(Outcomes, 2, simplify = FALSE)))
library(combinat)
library(writexl)
library(readxl)
library(dplyr)
# Data and basic processing -----------------------------------------------
# Import odds ratios for each team
DT <- read_excel("C:/Users/azizg/Downloads/Betting.xlsx", sheet = "Odds")
# Generate implied probabilities
calculate.implied.probability <- function(odds) {
if (odds >= 0) {
return(100 / (odds + 100))
} else {
return(odds / (odds - 100))
}
}
# Iterate through columns with odds (assuming they start from a certain column)
odds.columns <- 2:ncol(DT)  # Adjust this range based on your data
for (col in odds.columns) {
# Get column name for reference
col.name <- colnames(DT)[col]
# Calculate implied probabilities for each value in the column
implied.probabilities <- sapply(DT[[col]], calculate.implied.probability)
# Add new column with implied probabilities
new.col.name <- paste0(col.name, ".Implied Prob")  # New column name
DT[[new.col.name]] <- implied.probabilities
}
# Generate house edge
# Generating different lines ----------------------------------------------
# Different outcomes that can happen
options <- list(
Match = DT$Match,
Outcome = c("Favorite wins", "Draw", "Underdog wins")
)
outcomes <- expand.grid(options)
# Merge outcomes onto the datatable
merged.df <- merge(outcomes, DT, by = "Match")
# Group by 'Group' and generate combinations of 'Values'
df.combinations <- merged.df %>%
group_by(Match) %>%
summarize(Combinations = list(combn(outcomes, 2, simplify = FALSE)))
df.combinations
View(df.combinations)
View(df.combinations[[2]][[1]])
all.combinations <- expand.grid(df.combinations)
View(all.combinations)
View(all.combinations[[2]][[1]])
View(merged.df)
View(final.results)
library(combinat)
library(writexl)
library(readxl)
library(dplyr)
# Data and basic processing -----------------------------------------------
# Import odds ratios for each team
DT <- read_excel("C:/Users/azizg/Downloads/Betting.xlsx", sheet = "Odds")
# Generate implied probabilities
calculate.implied.probability <- function(odds) {
if (odds >= 0) {
return(100 / (odds + 100))
} else {
return(odds / (odds - 100))
}
}
# Iterate through columns with odds (assuming they start from a certain column)
odds.columns <- 2:ncol(DT)  # Adjust this range based on your data
for (col in odds.columns) {
# Get column name for reference
col.name <- colnames(DT)[col]
# Calculate implied probabilities for each value in the column
implied.probabilities <- sapply(DT[[col]], calculate.implied.probability)
# Add new column with implied probabilities
new.col.name <- paste0(col.name, ".Implied Prob")  # New column name
DT[[new.col.name]] <- implied.probabilities
}
# Generate house edge
# Generating different lines ----------------------------------------------
# Different outcomes that can happen
options <- list(
Match = DT$Match,
Outcome = c("Favorite wins", "Draw", "Underdog wins")
)
outcomes <- expand.grid(options)
# Merge outcomes onto the datatable
merged.df <- merge(outcomes, DT, by = "Match")
# Group by matches and generate combinations of match outcomes (Win, Draw, Lose)
df.combinations <- merged.df %>%
group_by(Match) %>%
summarize(Combinations = list(combn(outcomes, 2, simplify = FALSE)))
View(all.combinations)
View(merged.df)
library(combinat)
library(writexl)
library(readxl)
library(dplyr)
# Data and basic processing -----------------------------------------------
# Import odds ratios for each team
DT <- read_excel("C:/Users/azizg/Downloads/Betting.xlsx", sheet = "Odds")
# Generate implied probabilities
calculate.implied.probability <- function(odds) {
if (odds >= 0) {
return(100 / (odds + 100))
} else {
return(odds / (odds - 100))
}
}
# Iterate through columns with odds (assuming they start from a certain column)
odds.columns <- 2:ncol(DT)  # Adjust this range based on your data
for (col in odds.columns) {
# Get column name for reference
col.name <- colnames(DT)[col]
# Calculate implied probabilities for each value in the column
implied.probabilities <- sapply(DT[[col]], calculate.implied.probability)
# Add new column with implied probabilities
new.col.name <- paste0(col.name, ".Implied Prob")  # New column name
DT[[new.col.name]] <- implied.probabilities
}
# Generate house edge
# Generating different lines ----------------------------------------------
# Different outcomes that can happen
options <- list(
Match = DT$Match,
Outcome = c("Favorite wins", "Draw", "Underdog wins")
)
outcomes <- expand.grid(options)
# Merge outcomes onto the datatable
merged.df <- merge(outcomes, DT, by = "Match")
# Num.games
num.games <- nrow(DT$Match)
outcomes <- c("Favorite wins", "Draw", "Underdog wins")
# Generate all possible combinations
combinations <- expand.grid(rep(list(outcomes), num.games))
# Num.games
num.games <- nrow(DT)
outcomes <- c("Favorite wins", "Draw", "Underdog wins")
# Generate all possible combinations
combinations <- expand.grid(rep(list(outcomes), num.games))
View(combinations)
matches <- DT$Match
colnames(combinations) <- matches
View(DT)
df1 <- data.frame(Column1 = c("A", "B", "C"), Column2 = c("X", "Y", "Z"))
df2 <- data.frame(Name = c("Column1", "Column2", "Column3", "Column4"), Value = c(10, 20, 30, 40))
View(df2)
View(df1)
# Initialize a list to store results
results <- list()
# Loop through each column in df1
for (col in colnames(combinations)) {
# Get the column name
col.name <- col
# Match the column name with rows in df2
match.row <- DT[DT$Match == col.name, ]
}
View(match.row)
R.Version()
R.version
# Load necessary packages and setup environment  --------------------------
# Clear the global environment and run garbage collection
rm(list = names(.GlobalEnv))
gc()
# Load header script
# source("00 Header.R")
# Manage packages - set snapshot date, check R version, and package location
####manage_packages(snap.date <- "...", getRversion(), check.loc <- "H:/My Documents")
library(devtools)
library(data.table)
library(openxlsx)
library(stringr)
library(dplyr)
library(ggplot2)
# Load necessary packages and setup environment  --------------------------
# Clear the global environment and run garbage collection
rm(list = names(.GlobalEnv))
gc()
# Load header script
# source("00 Header.R")
# Manage packages - set snapshot date, check R version, and package location
####manage_packages(snap.date <- "...", getRversion(), check.loc <- "H:/My Documents")
library(devtools)
library(data.table)
library(openxlsx)
library(stringr)
library(dplyr)
#library(ggplot2)
# Get the path to the raw input file
input.file <- "C:/Users/azizg/Downloads/Cybersyn Case/01 Input/iowa_liquor_sales_2018_2021.csv"
DT <- fread(input.file, data.table = TRUE)
# Cleaning data -----------------------------------------------------------
# Clean date variables
is_valid <- grepl("^\\d{2}/\\d{2}/\\d{4}$", DT$Date)
DT[, Valid := is_valid]
unique(DT$Valid)
has_missing_dates <- DT[, any(is.na(Date))]
#if has_missing_dates == FALSE{}
DT[, Date := as.Date(Date, format = "%m/%d/%Y")]
DT[, `:=`(Month = month(Date), Year = year(Date))]
# Generate markup variable
DT[, `:=`(`Absolute Markup` = `State Bottle Retail` - `State Bottle Cost`,
`Percentage Markup` = (`State Bottle Retail`- `State Bottle Cost`) / `State Bottle Cost` * 100L)]
# Clean store name
# Processing:
# 1. Basic string cleaning
# 2. Removing any punctation or quotes within the name. After
DT[, cleaned_store_name := toupper(str_trim(str_squish(gsub("\\'|\\!\\?|\\\\.*$|#.*$|/.*$|\\d{4}.*", "", `Store Name`))))]
DT <- DT %>%
mutate(cleaned_store_name = ifelse(str_detect(cleaned_store_name, 'HY-VEE'), 'HY-VEE', cleaned_store_name)) %>%
mutate(cleaned_store_name = ifelse(str_detect(cleaned_store_name, 'FAREWAY'), 'FAREWAY', cleaned_store_name)) %>%
mutate(cleaned_store_name = ifelse(str_detect(cleaned_store_name, 'CASEYS'), 'CASEYS', cleaned_store_name)) %>%
mutate(cleaned_store_name = ifelse(str_detect(cleaned_store_name, 'HOMETOWN FOODS'), 'HOMETOWN FOODS', cleaned_store_name)) %>%
mutate(cleaned_store_name = ifelse(str_detect(cleaned_store_name, 'KWIK STOP'), 'KWIK STOP', cleaned_store_name)) %>%
mutate(cleaned_store_name = ifelse(str_detect(cleaned_store_name, 'LIQUOR BARN'), 'LIQUOR BARN', cleaned_store_name)) %>%
mutate(cleaned_store_name = ifelse(str_detect(cleaned_store_name, 'CVS'), 'CVS', cleaned_store_name)) %>%
mutate(cleaned_store_name = ifelse(str_detect(cleaned_store_name, 'TARGET'), 'TARGET', cleaned_store_name)) %>%
mutate(cleaned_store_name = ifelse(str_detect(cleaned_store_name, 'CENTRAL CITY 2'), 'CENTRAL CITY LIQUOR', cleaned_store_name)) %>%
mutate(cleaned_store_name = ifelse(str_detect(cleaned_store_name, 'CENTRAL CITY LIQUOR, INC.'), 'CENTRAL CITY LIQUOR', cleaned_store_name))
# 2. Which are the fastest growing types of liquor (e.g., vodka, tequila, rum, etc.)? How has market share changed over time?
#  a. Write a function that takes a list of liquor types as an input and visualizes the market share over time for each of those.
unique_category <- as.data.table(unique(DT[, `Category Name`]))
DT <- DT %>%
mutate(translated_liquor = case_when(
str_detect(`Category Name`, "WHISKIES|WHISKY|BOURBON|SCOTCH") ~ "WHISKY",
str_detect(`Category Name`, "RUM") ~ "RUM",
str_detect(`Category Name`, "VODKA") ~ "VODKA",
str_detect(`Category Name`, "BRANDIES") ~ "BRANDIES",
str_detect(`Category Name`, "GIN") ~ "GIN",
str_detect(`Category Name`, "LIQUEUR") ~ "LIQUEUR",
TRUE ~ `Category Name`  # If no condition matches, retain the original value
))
unique_category_new <- as.data.table(unique(DT[, translate_liquor]))
unique_category_new <- as.data.table(unique(DT[, translated_liquor]))
View(unique_category_new)
DT <- DT %>%
mutate(translated_liquor = case_when(
str_detect(`Category Name`, "WHISKIES|WHISKY|BOURBON|SCOTCH") ~ "WHISKY",
str_detect(`Category Name`, "RUM") ~ "RUM",
str_detect(`Category Name`, "VODKA") ~ "VODKA",
str_detect(`Category Name`, "BRANDIES") ~ "BRANDIES",
str_detect(`Category Name`, "GIN") ~ "GIN",
str_detect(`Category Name`, "LIQUEUR|TRIPLE SEC") ~ "LIQUEUR",
str_detect(`Category Name`, "SCHNAPPS") ~ "SCHNAPPS",
str_detect(`Category Name`, "TEQUILA|MEZCAL") ~ "TEQUILA & MEZCAL",
str_detect(`Category Name`, "SPIRITS") ~ "SPIRITS",
str_detect(`Category Name`, "SPECIAL ORDER|TEMPORARY") ~ "OTHER",
TRUE ~ `Category Name`  # If no condition matches, retain the original value
))
unique_category_new <- as.data.table(unique(DT[, translated_liquor]))
View(unique_category_new)
install.packages("ggplot2")
library(ggplot2)
# Calculate the market share
market_share_data <- calculate_market_share(DT, group_vars, time_var, liquor_types)
calculate_market_share <- function(data, group_vars, time_var, liquor_types) {
# Ensure the data is a data.table
setDT(data)
# Filter the data for the selected liquor types and aggregate sales
filtered_data <- data[`Category Name` %in% liquor_types]
# Aggregate sales by the specified grouping variables and time frame
# group_vars is expected to be a vector of variables like `Category Name`, `Vendor Name`
filtered_data <- filtered_data[, .(total_sales = sum(`Sale (Dollars)`)),
by = c(time_var, group_vars)]
# Calculate the market share for each group
filtered_data[, market_share := (total_sales / total_market_sales) * 100]
# Return the filtered data with calculated market share
return(filtered_data)
}
View(calculate_market_share)
# Set parameters
liquor_types <- c("WHISKY", "RUM", "VODKA", "GIN")
group_vars <- c("Category Name")  # You can change this to "Vendor Name" or others
time_var <- "Year"
# Calculate the market share
market_share_data <- calculate_market_share(DT, group_vars, time_var, liquor_types)
# Calculate the market share
market_share_data <- calculate_market_share(DT, group_vars, time_var, liquor_types)
Q
Q
calculate_market_share <- function(data, group_vars, time_var, liquor_types) {
browser()
# Ensure the data is a data.table
setDT(data)
# Filter the data for the selected liquor types and aggregate sales
filtered_data <- data[`Category Name` %in% liquor_types]
# Aggregate sales by the specified grouping variables and time frame
# group_vars is expected to be a vector of variables like `Category Name`, `Vendor Name`
filtered_data <- filtered_data[, .(total_sales = sum(`Sale (Dollars)`)),
by = c(time_var, group_vars)]
# Calculate the market share for each group
filtered_data[, market_share := (total_sales / total_market_sales) * 100]
# Return the filtered data with calculated market share
return(filtered_data)
}
# Calculate the market share
market_share_data <- calculate_market_share(DT, group_vars, time_var, liquor_types)
View(filtered_data)
market_size <- DT[, .(gin_sales = sum(`Sale (Dollars)`[`Category Name` == "GIN"]),
rest_sales = sum(`Sale (Dollars)`[`Category Name` != "GIN"])),
by = Year]
View(market_size)
market_size <- DT[, .(gin_sales = sum(`Sale (Dollars)`[`Category Name` == "GIN"]),
rest_sales = sum(`Sale (Dollars)`[`Category Name` != "GIN"])),
by = Year]
View(market_size)
top_ten_retailers <- DT[, .(total_sales = sum(`Sale (Dollars)`), total_volume = sum(`Volume Sold (Liters)`)), by = .(Year, cleaned_store_name)][
order(Year, -total_sales)
][
, head(.SD, 10L), by = Year
]
print(top_ten_retailers)
top_ten_retailers <- dcast(top_ten_retailers, Year ~ cleaned_store_name,
value.var = c("total_sales", "total_volume"))
View(top_ten_retailers)
top_ten_retailers <- DT[, .(total_sales = sum(`Sale (Dollars)`), total_volume = sum(`Volume Sold (Liters)`)), by = .(Year, cleaned_store_name)][
order(Year, -total_sales)
][
, head(.SD, 10L), by = Year
]
top_ten_retailers <- dcast(top_ten_retailers, Year,
value.var = c("total_sales", "total_volume"))
top_ten_retailers <- dcast(top_ten_retailers, Year ~ total_sales,
value.var = c("total_sales", "total_volume"), fill = 0)
View(top_ten_retailers)
top_ten_retailers <- DT[, .(total_sales = sum(`Sale (Dollars)`), total_volume = sum(`Volume Sold (Liters)`)), by = .(Year, cleaned_store_name)][
order(Year, -total_sales)
][
, head(.SD, 10L), by = Year
]
top_ten_retailers <- dcast(top_ten_retailers, Year ~ cleaned_store_name,
value.var = c("total_sales", "total_volume"), fill = TRUE)
View(top_ten_retailers)
top_ten_retailers <- DT[, .(total_sales = sum(`Sale (Dollars)`), total_volume = sum(`Volume Sold (Liters)`)), by = .(Year, cleaned_store_name)][
order(Year, -total_sales)
][
, head(.SD, 10L), by = Year
]
top_ten_retailers_cast <- dcast(top_ten_retailers, Year,
value.var = c("total_sales", "total_volume", "cleaned_store_name"), fill = TRUE)
top_ten_retailers_cast <- dcast(top_ten_retailers, Year ~ cleaned_store_name,
value.var = c("total_sales", "total_volume", "cleaned_store_name"), fill = TRUE)
View(top_ten_retailers_cast)
top_ten_retailers_cast <- dcast(top_ten_retailers, Year ~ Year,
value.var = c("total_sales", "total_volume", "cleaned_store_name"), fill = 0)
top_ten_retailers_cast <- dcast(top_ten_retailers, Year ~ Year,
value.var = list("total_sales", "total_volume"), fill = 0)
top_ten_retailers_cast <- dcast(
top_ten_retailers,
Year ~ cleaned_store_name,  # Rows will be Years, and columns will be cleaned_store_names
value.var = c("total_sales", "total_volume"),
fill = 0  # Fill missing combinations with 0
)
View(top_ten_retailers_cast)
View(head(DT))
setwd("C:/Users/azizg/Downloads/01 Job Search/09 Job hunt 2024/Cybersyn Case/~Production/Scripts")
# Clear global environment and run garbage collection
rm(list = names(.GlobalEnv))
gc()
# Load packages
library(data.table)
library(dplyr)
library(openxlsx)
# Load input
input_file <- "C:/Users/azizg/Downloads/06 Coding Projects/VA Housing Data/f7316a68-a1e1-4afc-88a9-3f314d3ce86d.csv"
DT <- fread(input_file, data.table = TRUE)
View(DT)
setDT()
setDT(DT)
sort(year)
?sort
sort(DT$year)
DT <- sort(DT$year)
